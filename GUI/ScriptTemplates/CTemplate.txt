/**
 *
 * Replay IOCTL 0x{0:x} script to {1:s} (in {2:s})
 * Auto-generated by CFB
 *
 */

 // Change to 1 to build as a DLL
 #define BUILD_AS_DLL 0

 // Change to 1 to show the error messages
 #define DEBUG 0

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdint.h>

#include <string>
#include <iostream>
#include <vector>

#define DEVICE_NAME   L"{1:s}"
#define DRIVER_NAME   L"{2:s}"
#define IOCTL_CODE    0x{0:x}

using namespace std;


HMODULE g_hLoadLibrary = NULL;

typedef HANDLE (WINAPI *CreateFileSig)(LPCWSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE);
typedef BOOL (WINAPI *CloseHandleSig)(HANDLE);
typedef BOOL (WINAPI* DeviceIoControlSig)(HANDLE,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,LPOVERLAPPED);
typedef DWORD (WINAPI* GetLastErrorSig)();


static inline bool unhexlify(const std::string& in, std::vector<uint8_t>& out)
{{
    for(size_t i=0; i<in.size(); i+=2)
    {{
        uint8_t hi = ((in[i] % 32 + 9) % 25) & 0x0f;
        uint8_t lo = ((in[i+1] % 32 + 9) % 25) & 0x0f;
        uint8_t b = hi<<4 | lo;
        out.push_back(b);
    }}
    return true;
}}




#if BUILD_AS_DLL == 1
extern "C" __declspec(dllexport) DWORD InjectPayload()
#else
int main(int argc, char** argv)
#endif
{{
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    BOOL bResult = FALSE;
    DWORD lpBytesReturned = 0;

    if(!g_hLoadLibrary)
        g_hLoadLibrary = GetModuleHandle(TEXT("kernel32.dll"));

    CreateFileSig pfnCreateFile = (CreateFileSig)GetProcAddress(g_hLoadLibrary, TEXT("CreateFileW"));
    CloseHandleSig pfnCloseHandle = (CloseHandleSig)GetProcAddress( g_hLoadLibrary, TEXT("CloseHandle"));
    DeviceIoControlSig pfnDeviceIoControl = (DeviceIoControlSig)GetProcAddress( g_hLoadLibrary, TEXT("DeviceIoControl"));
    GetLastErrorSig pfnGetLastError = (GetLastErrorSig)GetProcAddress( g_hLoadLibrary, TEXT("GetLastError"));

    std::vector<uint8_t> IrpDataIn;
    unhexlify( std::string({3:s}), IrpDataIn );
    std::vector<uint8_t> IrpDataOut;
    IrpDataOut.resize({4:d});


    do
    {{
#ifdef DEBUG
        wprintf(L"Getting handle for device '%s' with code %#x\n", DEVICE_NAME, IOCTL_CODE);
#endif
        hDevice = pfnCreateFile(
            DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

        if (hDevice == INVALID_HANDLE_VALUE)
        {{
#ifdef DEBUG
            wprintf(L"CreateFile() failed");
#endif
            break;
        }}

#ifdef DEBUG
        wprintf(L"Got device %p, sending payload\n", hDevice);
#endif
        bResult = pfnDeviceIoControl(
            hDevice,
            IOCTL_CODE,
            IrpDataIn.data(),
            IrpDataIn.size(),
            IrpDataOut.data(),
            IrpDataOut.size(),
            &lpBytesReturned,
            (LPOVERLAPPED) NULL
        );

        if (bResult==FALSE)
        {{
#ifdef DEBUG
            wprintf(L"DeviceIoControl failed");
#endif
            break;
        }}
    }}
    while(0);

    if(hDevice != INVALID_HANDLE_VALUE)
    {{
#ifdef DEBUG
        wprintf(L"Closing device %p\n", hDevice);
#endif
        pfnCloseHandle(hDevice);
    }}

    return pfnGetLastError();
}}


#if BUILD_AS_DLL == 1
extern "C" BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{{
    switch (ul_reason_for_call)
    {{
    case DLL_PROCESS_ATTACH:
        InjectPayload();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }}

    return TRUE;
}}

extern "C" __declspec(dllexport) DWORD TestInjection()
{{
#ifdef DEBUG
    wprintf(L"TestInjection() works\n");
#endif
    return ERROR_SUCCESS;
}}
#endif